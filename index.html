<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Rasin&#039;s Blog</title><meta property="og:type" content="blog"><meta property="og:title" content="Rasin&#039;s Blog"><meta property="og:url" content="https://rasin.me/"><meta property="og:site_name" content="Scienage Mafelteens"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://rasin.me/img/og_image.png"><meta property="article:author" content="Rasin Gue"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://rasin.me"},"headline":"Rasin's Blog","image":["https://rasin.me/img/og_image.png"],"author":{"@type":"Person","name":"Rasin Gue"},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-166789681-2" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-166789681-2');</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Rasin&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2021-04-12T10:35:55.000Z" title="2021-04-12T10:35:55.000Z">2021-04-12</time><span class="level-item">21 分钟 读完 (大约 3104 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/12/GVGAI%20Book%20Chapter%203%20-%20Planning%20in%20GVGAI/">GVGAI Book Chapter 3 - Planning in GVGAI</a></h1><div class="content"><p><a href="https://gaigresearch.github.io/gvgaibook/">书籍网站</a><br><a href="https://gaigresearch.github.io/gvgaibook/PDF/chapters/ch03.pdf?raw=true">本章原文</a><br><a href="https://gaigresearch.github.io/gvgaibook/PDF/exercises/exercises03.pdf?raw=true">本章练习</a></p>
<hr>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>Planning</code>是指制定行动计划以解决给定的问题。当给定当前状态和玩家要采取的行动时，可以使用环境模型来模拟可能的未来状态，该模型将被称为前向模型（Forward Model）。Monte Carlo Tree Search（MCTS）和Rolling Horizon Evolutionary Algorithms（RHEA）是构建大多数Planning Ai的基础，这两种方法互不相同：第一种方法从可能的游戏动作和状态种构建树，提取统计信息以决定在任何给定状态下下一步该怎么做；第二种方法一开始就定好整个计划，并使用进化计算来组合和修改它们，从而最终获得在游戏中执行的最佳选择。</p>
<p>GVGAI问题可以看作是多目标优化问题：游戏中的计分系统可能具有欺骗性，并且AI不仅需要专注于获得得分（如在传统的街机游戏中一样），而且还需要着眼于解决问题和赢得比赛，甚至还要考虑时间限制。 </p>
<h1 id="蒙特卡洛搜索树"><a href="#蒙特卡洛搜索树" class="headerlink" title="蒙特卡洛搜索树"></a>蒙特卡洛搜索树</h1><p>该算法通过一次添加单个节点来构建以不对称方式增长的搜索树，并通过使用从节点状态到游戏结束的自玩游戏来估算其游戏理论值。 书中的每个节点都会保存某些统计数据，这些统计数据表明在状态 \(s\) 下选择动作 \(a\) 时获得的奖励实验均值 \(Q(s, a)\)，从给定状态 \(s(N(s, a))\) 以及访问状态 \(s\) 的次数 \(N(s)\)。该算法通过模拟游戏中的动作，在连续的迭代中构建树，并根据这些统计信息做出选择。</p>
<p>MCTS的每个迭代都基于这几个步骤：</p>
<ul>
<li>树选择</li>
<li>扩展</li>
<li>模拟</li>
<li>后向传播 </li>
</ul>
<p><img src="https://raw.githubusercontent.com/rasin-tsukuba/blog-images/master/img/20210413151308.png" alt="Figure 1"></p>
<p>刚开始，树只由根节点组成，存储了当前的游戏状态。在<strong>扩展</strong> 步骤中，如果游戏还未结束，树从根部开始搜索到一个最大深度。在这一步中，动作可以用 <em>multi-armed bandit</em>策略将其应用到前向模型中。</p>
<p><em>Multi-armed bandit</em> 策略来源于一个多臂老虎机。当摇动杆时，从一个未知的概率分布返回一个奖励 \(r\)。这个问题的目的是在按一定顺序摇动杆后最大程度减少后悔（或者最大化累计奖励）。这里后悔被定义成一个当选择到一个并非最优的杆时的机会损失。好的政策通过平衡对可用杆的探索与对过去提供更好回报的杆的利用之间的平衡来选择行动。</p>
<p>Upper Confidence Bound (UCB1)：</p>
<p>$$<br>a* = \arg \max_{a \in A(s)} \large{ Q(s, a) + C\sqrt{\frac{\ln N(s)}{N(s, a)}}\large}<br>$$</p>
<p>该函数的目标是找到一个动作 \(a\)可以使UCB1函数最大化。\(Q(s, a)\)看作是 <em>发掘*项，第二项是 *探索</em> 项。探索项与给定状态 \(s\)，每个动作 \(a\)被选择的参数\(N(s,a)\)，以及从当前状态中选取动作的数量\(N(s)\)。参数 \(C\)用于平衡发掘与探索。当\(C\) 为0时，UCB1采用贪婪策略每次都选择平均当前收益最高的动作。如果奖励 \(Q(s, a)\)被正则化到 \([0, 1]\) 之间，常用的常熟值为 \(\sqrt(2)\)。不同游戏常数值的选择可能不同。</p>
<p>在 <em>树选择</em> 步骤中，直到找到子节点少于动作数量的节点。 此时，在 <em>扩展</em> 步骤加入一个子节点，开启 <em>模拟</em> 步骤。从新节点开始，MCTS执行蒙特卡洛模拟。这时候选择一个随机的动作（均匀随机或有偏随机）一直到游戏结束（或到达一个预定义的深度）。最后，在 <em>反向传播</em> 步骤中，使用状态评估中获得的奖励，为遍历的每个节点更新统计量 \(N(s), N(s, a), Q(s, a)\)。这些步骤会循环执行，直到达到一个结束条件（例如迭代次数或者预计的时间）。</p>
<p>知道所有的迭代完成，MCTS将会推荐agent在游戏中采取的动作。该推荐策略根据存储在根节点中的统计信息来确定动作。可能推荐最近常采用的动作或者得到最高平均收益的策略，也可能直接计算公式得到返回的动作。以下时MCTS算法的伪代码。</p>
<p><img src="https://raw.githubusercontent.com/rasin-tsukuba/blog-images/master/img/20210413162718.png" alt="pseudocode"></p>
<p>MCTS被认为是随时可用的算法，因为它能够在任何时刻提供有效的下一步选择。 这不同于其他算法（例如单人游戏中的A*算法，以及两人游戏中的标准“Min-Max”），这些算法通常仅在完成后才提供给下一次游玩。这使MCTS在实时领域十分合适，在实时域中，决策时间预算受到限制，从而影响了可以执行的迭代次数。</p>
<p>GVGAI也提供了基础版本的MCTS。在实际应用中，\(C\) 选取为 \(\sqrt(2)\)，且rollout深度定为10 。在模拟阶段结束时达到的每个状态都使用该时刻的游戏得分进行评估，并在比赛期间见过的最小和最大得分之间进行归一化。 如果状态为终局，则分配的奖励为较大的正数（如果游戏获胜）或负数（如果游戏输了）。 </p>
<p>虽然MCTS在GVGAI平台上的表现很好，但是没有游戏相关的知识支撑算法。Value function 仅基于得分和游戏结束状态，这些概念存在于所有游戏中，因此通常在GVGP方法中使用。 </p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>以一个简单的游戏为例，该游戏的目的是使每次动作选取数字的累积和接近0.动作的可选范围是 <code>[-2, 2, -3, 3] * 回合数</code>。</p>
<p>首先构建 <code>State</code> 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">class State():</span><br><span class="line">    NUM_TURNS &#x3D; 10 #最多10回合</span><br><span class="line">    GOAL &#x3D; 0 #目标是累计和为 0</span><br><span class="line">    MOVES &#x3D; [2, -2, 3, -3] # 动作可选范围</span><br><span class="line">    MAX_VALUE &#x3D; (5.0 * (NUM_TURNS - 1) * NUM_TURNS) &#x2F; 2 # 最大值为225</span><br><span class="line">    num_moves &#x3D; len(MOVES) # 动作数量</span><br><span class="line"></span><br><span class="line">    # 初始化类</span><br><span class="line">    # 累计和为0，动作为空列表，总回合数由传入参数决定</span><br><span class="line">    def __init__(self, value&#x3D;0, moves&#x3D;[], turn&#x3D;NUM_TURNS):</span><br><span class="line">        self.value &#x3D; value</span><br><span class="line">        self.moves &#x3D; moves</span><br><span class="line">        self.turn &#x3D; turn</span><br><span class="line"></span><br><span class="line">    # 下一个状态</span><br><span class="line">    # 通过当前状态得到下一状态</span><br><span class="line">    def next_state(self):</span><br><span class="line">        # 从回合数乘动作的列表中随机选择</span><br><span class="line">        nextmove &#x3D; random.choice([x * self.turn for x in self.MOVES])</span><br><span class="line">        # 更新下一个状态的成员值</span><br><span class="line">        next &#x3D; State(self.value + nextmove, self.moves + [nextmove], self.turn - 1)</span><br><span class="line">        # 返回下一个状态</span><br><span class="line">        return next</span><br><span class="line"></span><br><span class="line">    # 终结状态</span><br><span class="line">    def terminal(self):</span><br><span class="line">        # 如果剩余回合数为0</span><br><span class="line">        if self.turn &#x3D;&#x3D; 0:</span><br><span class="line">            # 结束</span><br><span class="line">            return True</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line">    # 奖励</span><br><span class="line">    def reward(self):</span><br><span class="line">        # 游戏的奖励定义为</span><br><span class="line">        # 用1减去当前值减去目标值的绝对值除以最大值</span><br><span class="line">        # 实际上就是归一化之后距离0越近奖励越多</span><br><span class="line">        r &#x3D; 1.0 - (abs(self.value - self.GOAL) &#x2F; self.MAX_VALUE)</span><br><span class="line">        return r</span><br><span class="line"></span><br><span class="line">    # 若对象在其生命周期内保持不变，而且能与其他对象相比较，那么这个对象是可哈希的</span><br><span class="line">    # 通过__hash__返回一个int值，用来标记这个对象。</span><br><span class="line">    # 这里是通过操作序列来标记两个状态是否相同</span><br><span class="line">    def __hash__(self):</span><br><span class="line">        return int(hashlib.md5(str(self.moves).encode(&#39;utf-8&#39;)).hexdigest(), 16)</span><br><span class="line"></span><br><span class="line">    # 在调用 &#96;&#x3D;&#x3D;&#96; 操作符，，实际上是调用 &#96;__eq__&#96;方法</span><br><span class="line">    def __eq__(self, other):</span><br><span class="line">        if hash(self) &#x3D;&#x3D; hash(other):</span><br><span class="line">            return True</span><br><span class="line">        else False</span><br><span class="line"></span><br><span class="line">    # __repr__主要用于调试和开发</span><br><span class="line">    # 用于打印内容</span><br><span class="line">    # repr()更能显示出对象的类型、值等信息，对象描述清晰</span><br><span class="line">    def __repr__(self):</span><br><span class="line">        s &#x3D; &quot;Value: %d; Moves: %s&quot; % (self.value, self.moves)</span><br><span class="line">        return s</span><br></pre></td></tr></table></figure>

<p>之后定义蒙特卡洛树类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Node():</span><br><span class="line">    def __init__(self, state, parent&#x3D;None):</span><br><span class="line">        self.visits &#x3D; 1 # 被访问次数默认为1</span><br><span class="line">        self.reward &#x3D; 0.0 # 奖励为0</span><br><span class="line">        self.state &#x3D; state # 初始状态</span><br><span class="line">        self.children &#x3D; [] # 子节点为空列表</span><br><span class="line">        self.parent &#x3D; parent # 初始父节点</span><br><span class="line"></span><br><span class="line">    # 为蒙特卡洛树增加子节点</span><br><span class="line">    def add_child(self, child_state):</span><br><span class="line">        # 直接在子节点列表里面添加一个实例，状态为子节点状态，子节点的父节点是自己</span><br><span class="line">        child&#x3D;Node(child_state, self)</span><br><span class="line">        self.children.append(child)</span><br><span class="line"></span><br><span class="line">    # 更新状态</span><br><span class="line">    def update(self, reward):</span><br><span class="line">        # 更新奖励，且访问数量加1</span><br><span class="line">        self.reward +&#x3D; reward</span><br><span class="line">        self.visits +&#x3D; 1</span><br><span class="line"></span><br><span class="line">    # 判断是否完全拓展</span><br><span class="line">    def fully_expanded(self):</span><br><span class="line">        # 如果子节点的数量已经与状态中的动作数量相等了，则已搜索完毕</span><br><span class="line">        if len(self.children) &#x3D;&#x3D; self.state.num_moves:</span><br><span class="line">            return True</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line">    # 打印内容</span><br><span class="line">    def __repr__(self):</span><br><span class="line">        s &#x3D; &quot;Node; children: %d; visits: %d; reward: %f&quot; % (len(self.children), self.visits, self.reward)</span><br><span class="line">        return s</span><br></pre></td></tr></table></figure>

<p>在定义完基本数据结构之后，就要定义策略方法了。首先定义默认策略：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">def DEFAULTPOLICY(state):</span><br><span class="line">    # 如果还未搜索结束</span><br><span class="line">    while state.terminal() &#x3D;&#x3D; False:</span><br><span class="line">        # 则继续搜索 找到下一个状态</span><br><span class="line">        state &#x3D; state.next_state()</span><br><span class="line">    # 返回奖励值</span><br><span class="line">    return state.reward()</span><br><span class="line"></span><br><span class="line">def EXPAND(node):</span><br><span class="line">    # 首先先找出已经搜索过的子节点，保存下来</span><br><span class="line">    tried_children &#x3D; [c.state for c in node.children]</span><br><span class="line">    # 找到该状态的下一个状态</span><br><span class="line">    new_state &#x3D; node.state.next_state()</span><br><span class="line">    # 循环验证，若该状态已被尝试</span><br><span class="line">    while new_state in tried_children:</span><br><span class="line">        # 再增加一个新状态，直到没有重复</span><br><span class="line">        new_state &#x3D; node.state.next_state()</span><br><span class="line">    # 将新状态加入子节点</span><br><span class="line">    node.add_child(new_state)</span><br><span class="line">    # 返回最后一个节点</span><br><span class="line">    return node.children[-1]</span><br><span class="line"></span><br><span class="line">def TREEPOLICY(node):</span><br><span class="line">    # 如果有多种选择时且你不想要完全扩展时的一个强制“发掘“的奇技淫巧</span><br><span class="line"></span><br><span class="line">    # 在还未完结 时</span><br><span class="line">    while node.state.terminal() &#x3D;&#x3D; False:</span><br><span class="line">        # 如果子节点数量为0</span><br><span class="line">        if len(node.children) &#x3D;&#x3D; 0:</span><br><span class="line">            # 扩展</span><br><span class="line">            return EXPAND(node)</span><br><span class="line">        # 随机，二分之一概率</span><br><span class="line">        elif random.uniform(0, 1) &lt; 0.5:</span><br><span class="line">            # 找到最佳子节点</span><br><span class="line">            node &#x3D; BESTCHILD(node, SCALAR)</span><br><span class="line">        # 否则</span><br><span class="line">        else:</span><br><span class="line">            # 如果还未完全扩展</span><br><span class="line">            if node.fully_expanded() &#x3D;&#x3D; False:</span><br><span class="line">                # 扩展</span><br><span class="line">                return EXPAND(node)</span><br><span class="line">            # 否则返回最佳子节点</span><br><span class="line">            else:</span><br><span class="line">                node &#x3D; BESTCHILD(node, SCALAR)</span><br><span class="line">    return node</span><br><span class="line"></span><br><span class="line">def BESTCHILD(node, scalar):</span><br><span class="line">    # 最高分初始为0</span><br><span class="line">    bestscore &#x3D; 0.0</span><br><span class="line">    # 最佳子节点列表为空</span><br><span class="line">    bestchildren &#x3D; []</span><br><span class="line">    # 遍历所有的子节点</span><br><span class="line">    for c in node.children:</span><br><span class="line">        # 根据公式计算</span><br><span class="line">        # 发掘项</span><br><span class="line">        exploit &#x3D; c.reward &#x2F; c.visits</span><br><span class="line">        # 探索项</span><br><span class="line">        explore &#x3D; math.sqrt(2.0 * math.log(node.visits) &#x2F; float(c.visits))</span><br><span class="line">        # UCB1总分为两者之和</span><br><span class="line">        score &#x3D; exploit + scalar * explore</span><br><span class="line"></span><br><span class="line">        # 找到最高分</span><br><span class="line">        if score &#x3D;&#x3D; bestscore:</span><br><span class="line">            bestchildren.append(c)</span><br><span class="line">        if score &gt; bestscore:</span><br><span class="line">            bestchildren &#x3D; [c]</span><br><span class="line">            bestscore &#x3D; score</span><br><span class="line"></span><br><span class="line">    # 如果最佳子节点数量为0，则报错</span><br><span class="line">    if len(bestchildren) &#x3D;&#x3D; 0:</span><br><span class="line">        logger.warn(&quot;OOPs: no best child found, probably fatal&quot;)</span><br><span class="line">    # 随即返回一个最佳子节点</span><br><span class="line">    return random.choice(bestchildren)</span><br><span class="line"></span><br><span class="line"># 复制树</span><br><span class="line">def BACKUP(node,reward):</span><br><span class="line">	while node!&#x3D;None:</span><br><span class="line">		node.visits+&#x3D;1</span><br><span class="line">		node.reward+&#x3D;reward</span><br><span class="line">		node&#x3D;node.parent</span><br><span class="line">	return</span><br></pre></td></tr></table></figure>

<p>总搜索函数为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 输入耗费预算和根节点</span><br><span class="line">def UCTSEARCH(budget, root):</span><br><span class="line">    # 在预算范围内循环</span><br><span class="line">    for iter in range(int(budget)):</span><br><span class="line">        # 每10000次打印一次</span><br><span class="line">        if iter%10000 &#x3D;&#x3D; 9999:</span><br><span class="line">            logger.info(&quot;simulation: %d&quot; %iter)</span><br><span class="line">            logger.info(root)</span><br><span class="line"></span><br><span class="line">            # 通过TreePolicy找到最佳子节点</span><br><span class="line">            front &#x3D; TREEPOLICY(root)</span><br><span class="line">            # 得到奖励</span><br><span class="line">            reward &#x3D; DEFAULTPOLICY(front.state)</span><br><span class="line">            # 备份搜索树</span><br><span class="line">            BACKUP(front, reward)</span><br><span class="line">    # 返回最佳策略</span><br><span class="line">    return BESTCHILD(root, 0)</span><br></pre></td></tr></table></figure>

<p>那么一个完整的执行过程写在 <code>main</code> 函数中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    parser &#x3D; argparse.ArgumentParser(description&#x3D;&#39;MCTS research code&#39;)</span><br><span class="line">    # 模拟预算参数</span><br><span class="line">    parser.add_argument(&#39;--num_sims&#39;, action&#x3D;&quot;store&quot;, required&#x3D;True, type&#x3D;int)</span><br><span class="line">    # 搜索深度参数</span><br><span class="line">    parser.add_argument(&#39;--levels&#39;, action&#x3D;&quot;store&quot;, required&#x3D;True, type&#x3D;int, choices&#x3D;range(State.NUM_TURNS))</span><br><span class="line">    args &#x3D; parser.parse_args()</span><br><span class="line"></span><br><span class="line">    # 定义空树</span><br><span class="line">    current_node &#x3D; Node(State())</span><br><span class="line">    for l in range(args.levels):</span><br><span class="line">        current_node &#x3D; UCTSEARCH(args.num_sims &#x2F; (l + 1), current_node)</span><br><span class="line">        print(&quot;level %d&quot; % l)</span><br><span class="line">        print(&quot;Num Children: %d&quot; % len(current_node.children))</span><br><span class="line">        for i, c in enumerate(current_node.children):</span><br><span class="line">            print(i, c)</span><br><span class="line">        print(&quot;Best Child: %s&quot; % current_node.state)</span><br><span class="line"></span><br><span class="line">        print(&quot;--------------------------------&quot;)</span><br></pre></td></tr></table></figure>

<p>若 <code>num_sims</code> 为 <code>100000</code>，深度 <code>levels</code> 为 <code>9</code>，一次模拟结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">level 0</span><br><span class="line">Num Children: 2</span><br><span class="line">0 Node; children: 0; visits: 2; reward: 0.928889</span><br><span class="line">1 Node; children: 0; visits: 2; reward: 0.920000</span><br><span class="line">Best Child: Value: -30; Moves: [-30]</span><br><span class="line">--------------------------------</span><br><span class="line">level 1</span><br><span class="line">Num Children: 1</span><br><span class="line">0 Node; children: 0; visits: 2; reward: 0.911111</span><br><span class="line">Best Child: Value: -3; Moves: [-30, 27]</span><br><span class="line">--------------------------------</span><br><span class="line">level 2</span><br><span class="line">Num Children: 1</span><br><span class="line">0 Node; children: 0; visits: 2; reward: 0.813333</span><br><span class="line">Best Child: Value: -27; Moves: [-30, 27, -24]</span><br><span class="line">--------------------------------</span><br><span class="line">level 3</span><br><span class="line">Num Children: 1</span><br><span class="line">0 Node; children: 0; visits: 2; reward: 0.826667</span><br><span class="line">Best Child: Value: -48; Moves: [-30, 27, -24, -21]</span><br><span class="line">--------------------------------</span><br><span class="line">level 4</span><br><span class="line">Num Children: 2</span><br><span class="line">0 Node; children: 0; visits: 2; reward: 0.848889</span><br><span class="line">1 Node; children: 0; visits: 2; reward: 0.764444</span><br><span class="line">Best Child: Value: -30; Moves: [-30, 27, -24, -21, 18]</span><br><span class="line">--------------------------------</span><br><span class="line">level 5</span><br><span class="line">Num Children: 0</span><br><span class="line">Best Child: Value: -20; Moves: [-30, 27, -24, -21, 18, 10]</span><br><span class="line">--------------------------------</span><br><span class="line">level 6</span><br><span class="line">Num Children: 0</span><br><span class="line">Best Child: Value: -12; Moves: [-30, 27, -24, -21, 18, 10, 8]</span><br><span class="line">--------------------------------</span><br><span class="line">level 7</span><br><span class="line">Num Children: 0</span><br><span class="line">Best Child: Value: -6; Moves: [-30, 27, -24, -21, 18, 10, 8, 6]</span><br><span class="line">--------------------------------</span><br><span class="line">level 8</span><br><span class="line">Num Children: 0</span><br><span class="line">Best Child: Value: -12; Moves: [-30, 27, -24, -21, 18, 10, 8, 6, -6]</span><br><span class="line">--------------------------------</span><br></pre></td></tr></table></figure>

<h1 id="基于知识的快速进化MCTS"><a href="#基于知识的快速进化MCTS" class="headerlink" title="基于知识的快速进化MCTS"></a>基于知识的快速进化MCTS</h1></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2021-04-11T19:35:55.000Z" title="2021-04-11T19:35:55.000Z">2021-04-11</time><span class="level-item">15 分钟 读完 (大约 2243 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/11/VGDL%E8%8C%83%E4%BE%8B%E8%A7%A3%E8%AF%BB/">VGDL范例解读</a></h1><div class="content"><p><a href="http://schaul.site44.com/publications/pyvgdl.pdf">A Video Game Description Language for Model-based or Interactive Learning</a></p>
<h2 id="Alians-VGDL"><a href="#Alians-VGDL" class="headerlink" title="Alians VGDL"></a><a href="https://github.com/GAIGResearch/GVGAI/blob/master/examples/gridphysics/aliens.txt">Alians VGDL</a></h2><h1 id="VGDL论文"><a href="#VGDL论文" class="headerlink" title="VGDL论文"></a>VGDL论文</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>pyVGDL</code> 是一种视频游戏描述语言，以促进大型或多样化游戏组合的生成，这些游戏组合也可以用于评估具有通用性的体系结构和算法，例如强化学习和进化搜索。为了使这一目的更加可行，作者将游戏生成领域限制为2D街机风格游戏，其具有足够多样化的空间。</p>
<p><code>pyVGDL</code>应该具有<strong>清晰</strong>，<strong>易读</strong>且<strong>明确</strong>的特性。其词汇应具有较高的<strong>表达力</strong>，比你更具有相当新颖的<strong>扩展性</strong>。其表示结构应该<strong>易于解析</strong>，可以<strong>自动生成游戏</strong>，默认设置和健全检查能够使大多数随机游戏描述<strong>真正可玩</strong>。</p>
<h2 id="pyVGDL-语言"><a href="#pyVGDL-语言" class="headerlink" title="pyVGDL 语言"></a>pyVGDL 语言</h2><p>基于Python语言和 <code>pygame</code>库开发。完整<a href="https://github.com/schaul/py-vgdl">开源代码地址</a>。</p>
<p>整个游戏将限制在一个二维矩形空间内，所有游戏相关的<em>对象</em>都再此空间内。受全局或特定于对象的规则和玩家动作的影响，对象可以<em>移动</em>，与其他对象<em>交互</em>，<em>消失</em>或<em>生成新对象</em>。 </p>
<p>一个游戏分为两个部分：<em>关卡描述</em>描述了所有对象的位置和游戏2D布局； <em>游戏描述</em>描述了游戏中所有动态和潜在的对象互动。</p>
<p>一个关卡描述的示例：具有固定的长，，用不同的符号代表不同的对象。例如：<code>A</code>代表在左上角生成的玩家，需要找到钥匙 <code>+</code>到目的地 <code>G</code>离开迷宫。通过避开或击杀怪物 <code>1</code>来完成关卡。其余的 <code>w</code>代表迷宫的墙体。</p>
<p><img src="https://raw.githubusercontent.com/rasin-tsukuba/blog-images/master/img/20210411102437.png" alt="Figure 1"></p>
<p>而游戏描述则由四大块指令组成。以下使塞尔达传说的一个示例：</p>
<p><img src="https://raw.githubusercontent.com/rasin-tsukuba/blog-images/master/img/20210411103457.png" alt="Figure 2"></p>
<ul>
<li><code>LevelMapping</code> 定义了如何将对应字符从关卡描述映射到对象。例如 <code>1</code> 可以映射到 <code>monster</code> 类。</li>
<li><code>SpriteSet</code> 定义了对象类，都是由一个抽象类 <code>VGDLSprite</code> 派生出来的。对象类以树的形式 （使用缩进）来组织，子类将会继承其父类的属性。例如玩家的 <code>avatar</code> 类中就有两个子类，其中一个是得到钥匙的，另一个没有。所有的类都可以使用关键字参数，例如 <code>key</code> 和 <code>goal</code> 就是用了不同的 <code>color</code>参数，都具有相同的 <code>Immovable</code> 参数。</li>
<li><code>InteractionSet</code> 定义了当两个对象碰撞时将会发生的潜在事件。这些互动由事件方法定义，也可以使用参数。例如，<code>sword</code> 可以击杀 <code>monster</code>， <code>monster</code> 可以击杀玩家，没有对象可以穿透 <code>walls</code>，当林克找到 <code>key</code> 对象时，<code>avatar</code> 类将会转换。</li>
<li><code>TerminationSet</code> 定义了游戏结束的不同方法，每一行都是一个结束评判。例如，是否到达 <code>goal</code>。</li>
</ul>
<p>还有一些其他的设置例如：</p>
<ul>
<li>物理类型 ：<em>continuous</em>, <em>grid based</em>, <em>friction</em>, <em>gravity</em>, …</li>
<li>移动动态：<em>straight</em>, <em>random motion</em>, <em>player-control</em>, …</li>
<li>互动作用：<em>bouncing</em>, <em>destruction</em>, <em>spawning</em>, <em>transforming</em>, …</li>
</ul>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>生成，克隆和消除对象，从一种类型转换到另一种</li>
<li>自走式对象运动，采取一致或随机的动作，或者不规律变化</li>
<li>非确定性的追赶和逃避行为</li>
<li>根据用户操作或碰撞效果触发的固定或随机时间表在任意对象位置生成的发射对象</li>
<li>粘性，即一个物体拉动另一个物体</li>
<li>其他对象或屏幕边缘的跳动和环绕行为</li>
<li>将物体传送到固定或随机的终端位置</li>
<li>连续的物理效应，例如惯性，摩擦和重力</li>
<li>随机影响，例如沿当前方向滑动或阵风</li>
</ul>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><code>pyVGDL</code> 是基于 Python语言本身。游戏描述必须严格保持一个树形结构，更类似于XML 样式。</p>
<p><img src="https://raw.githubusercontent.com/rasin-tsukuba/blog-images/master/img/20210411181047.png" alt="Figure 4"></p>
<p>整个解析器包含了游戏描述和关卡描述的解析。解析和初始化在一秒之内完成，基本可以使游戏马上可玩。</p>
<h2 id="解释器和接口"><a href="#解释器和接口" class="headerlink" title="解释器和接口"></a>解释器和接口</h2><ul>
<li>玩家类型：支持玩家直接用键盘参与，以及机器人调用接口。接口符合 <code>PyBrain</code>机器学习库的 <code>Agent/Environement/Task</code>模型，通过 <code>getSensors</code>和<code>performAction</code>方法来进行互动。</li>
<li>玩家数量：支持单人（目前已支持多人）</li>
<li>视角：默认游戏以鸟瞰视角游玩，而且全地图可见。我们也提供了第一人称视角，这样游戏将只有部分可见。</li>
<li>观察：它们可以以中等分辨率的图像或“干净”的形式在视觉上呈现，仅表示功能不同的组件。然而，强大的agent能够像人类一样识别视觉流。</li>
<li>模型：我们提供了一种转换工具，可以将游戏动态转换为马尔可夫决策过程的完整转换矩阵 。这仅对状态组合不会爆炸增加的游戏是可行的。 </li>
</ul>
<h1 id="VGDL-范例"><a href="#VGDL-范例" class="headerlink" title="VGDL 范例"></a>VGDL 范例</h1><h2 id="Lunar-Lander"><a href="#Lunar-Lander" class="headerlink" title="Lunar Lander"></a>Lunar Lander</h2><p>Lunar Lander的游戏描述文件为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BasicGame</span><br><span class="line">    LevelMapping</span><br><span class="line">        G &gt; pad</span><br><span class="line">    SpriteSet</span><br><span class="line">        pad &gt; Passive color&#x3D;BLUE</span><br><span class="line">        avatar &gt; InertialAvatar physicstype&#x3D;GravityPhysics</span><br><span class="line">    InteractionSet</span><br><span class="line">        avatar wall &gt; killSprite</span><br><span class="line">        avatar EOS &gt; killSprite</span><br><span class="line">        pad avatar &gt; killIfSlow</span><br><span class="line">    TerminationSet</span><br><span class="line">        SpriteCounter stype&#x3D;pad limit&#x3D;4 win&#x3D;True</span><br><span class="line">        SpriteCounter stype&#x3D;avatar win&#x3D;False</span><br></pre></td></tr></table></figure>

<p>其中之一的关卡描述文件为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">wwwwwwwwwwwwwwwwwwwwwwwwwwww</span><br><span class="line">         w    w            w</span><br><span class="line">     A    wwww              </span><br><span class="line">                            </span><br><span class="line">                            </span><br><span class="line">                            </span><br><span class="line">                      www   </span><br><span class="line">                     wwww  w</span><br><span class="line">        w        wwwwwwwwGGw</span><br><span class="line">       wwwwwGGGwwwwwwwwwwwww</span><br><span class="line">     wwwwwwwwwwwwwwwwwwwwwww</span><br><span class="line">wwwwwwwwwwwwwwwwwwwwwwwwwwww</span><br></pre></td></tr></table></figure>

<p>从关卡描述中我们可以看出，<code>A</code>为玩家，<code>G</code>为降落地点，<code>w</code> 为墙体。</p>
<ul>
<li>LevelMapping: <code>G</code>为降落地点</li>
<li>SpriteSet: <code>pad</code> 被设为蓝色，玩家<code>avatar</code>的物理类型是受到重力影响的。</li>
<li>InteractionSet：<ul>
<li><code>avatar</code> 碰到墙体即被摧毁</li>
<li><code>avatar</code> 飞出游戏窗体外也被摧毁</li>
<li><code>avatar</code> 碰到 <code>pad</code> 如果速度过快也被摧毁</li>
</ul>
</li>
<li>TerminationSet: 由于总共落地点有五个，到达目的地会自动消除一个，因此剩下四格降落点时玩家胜利，否则失败。</li>
</ul>
<h2 id="Aliens"><a href="#Aliens" class="headerlink" title="Aliens"></a>Aliens</h2><p>游戏描述文件为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">BasicGame square_size&#x3D;32</span><br><span class="line">    SpriteSet</span><br><span class="line">        background &gt; Immovable img&#x3D;oryx&#x2F;space1 hidden&#x3D;True</span><br><span class="line">        base    &gt; Immovable    color&#x3D;WHITE img&#x3D;oryx&#x2F;planet</span><br><span class="line">        avatar  &gt; FlakAvatar   stype&#x3D;sam img&#x3D;oryx&#x2F;spaceship1</span><br><span class="line">        missile &gt; Missile</span><br><span class="line">            sam  &gt; orientation&#x3D;UP    color&#x3D;BLUE singleton&#x3D;True img&#x3D;oryx&#x2F;bullet1</span><br><span class="line">            bomb &gt; orientation&#x3D;DOWN  color&#x3D;RED  speed&#x3D;0.5 img&#x3D;oryx&#x2F;bullet2</span><br><span class="line">        alien   &gt; Bomber       stype&#x3D;bomb   prob&#x3D;0.01  cooldown&#x3D;3 speed&#x3D;0.8</span><br><span class="line">            alienGreen &gt; img&#x3D;oryx&#x2F;alien3</span><br><span class="line">            alienBlue &gt; img&#x3D;oryx&#x2F;alien1</span><br><span class="line">        portal  &gt; invisible&#x3D;True hidden&#x3D;True</span><br><span class="line">        	portalSlow  &gt; SpawnPoint   stype&#x3D;alienBlue  cooldown&#x3D;16   total&#x3D;20 img&#x3D;portal</span><br><span class="line">        	portalFast  &gt; SpawnPoint   stype&#x3D;alienGreen  cooldown&#x3D;12   total&#x3D;20 img&#x3D;portal</span><br><span class="line"></span><br><span class="line">    LevelMapping</span><br><span class="line">        . &gt; background</span><br><span class="line">        0 &gt; background base</span><br><span class="line">        1 &gt; background portalSlow</span><br><span class="line">        2 &gt; background portalFast</span><br><span class="line">        A &gt; background avatar</span><br><span class="line"></span><br><span class="line">    TerminationSet</span><br><span class="line">        SpriteCounter      stype&#x3D;avatar               limit&#x3D;0 win&#x3D;False</span><br><span class="line">        MultiSpriteCounter stype1&#x3D;portal stype2&#x3D;alien limit&#x3D;0 win&#x3D;True</span><br><span class="line"></span><br><span class="line">    InteractionSet</span><br><span class="line">        avatar  EOS  &gt; stepBack</span><br><span class="line">        alien   EOS  &gt; turnAround</span><br><span class="line">        missile EOS  &gt; killSprite</span><br><span class="line"></span><br><span class="line">        base bomb &gt; killBoth</span><br><span class="line">        base sam &gt; killBoth scoreChange&#x3D;1</span><br><span class="line"></span><br><span class="line">        base   alien &gt; killSprite</span><br><span class="line">        avatar alien &gt; killSprite scoreChange&#x3D;-1</span><br><span class="line">        avatar bomb  &gt; killSprite scoreChange&#x3D;-1</span><br><span class="line">        alien  sam   &gt; killSprite scoreChange&#x3D;2</span><br></pre></td></tr></table></figure>

<p>其一关卡描述文件为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.............................</span><br><span class="line">000...........................</span><br><span class="line">000...........................</span><br><span class="line">..............................</span><br><span class="line">..............................</span><br><span class="line">..............................</span><br><span class="line">..............................</span><br><span class="line">....000......000000.....000...</span><br><span class="line">...00000....00000000...00000..</span><br><span class="line">...0...0....00....00...00000..</span><br><span class="line">................A.............</span><br></pre></td></tr></table></figure>

<p>从描述文件我们可以看出：</p>
<ul>
<li>LevelMapping: <ul>
<li><code>.</code> 为背景</li>
<li><code>0</code>为墙体（基地）</li>
<li><code>1</code> 为敌人产出生点</li>
<li><code>2</code>产生速度较快</li>
<li><code>A</code> 为玩家</li>
</ul>
</li>
<li>SpriteSet:<ul>
<li>背景不可移动，贴图位置为 <code>oryx/space1</code>，表现为隐藏不可互动</li>
<li>基地不可以调动，颜色为白色，贴图位置 <code>oryx/planet</code></li>
<li>玩家属于 <code>FlakAvatar</code>类，子弹类型为 <code>sam</code>，贴图位置 <code>oryx/spaceship1</code></li>
<li>导弹属于 <code>Missile</code> 类，分为两种：<ul>
<li><code>sam</code> 是向上射击的，颜色为蓝色，全屏只能存在一个，贴图位置 <code>oryx/bullet1</code></li>
<li><code>bomb</code> 是向下掉落的，颜色为红色，速度限制为 <code>0.5</code>，贴图位置 <code>oryx/bullet2</code></li>
</ul>
</li>
<li>敌人也有两种，属于<code>Bomber</code>类，子弹卫星为 <code>bomb</code>， 射击概率为 <code>0.01</code>，冷却时间为 <code>3</code>，速度为 <code>0.8</code><ul>
<li>绿色敌人贴图 <code>oryx/alien3</code></li>
<li>蓝色敌人贴图 <code>oryx/alien1</code></li>
</ul>
</li>
<li>传送点不可见，也不可互动<ul>
<li>慢速传送点产生蓝色敌人，冷却时间为 <code>16</code>，总计产生20个</li>
<li>快速传送点产生绿色敌人，冷却时间为 <code>12</code>，总计产生20个</li>
</ul>
</li>
</ul>
</li>
<li>InteractionSet<ul>
<li>玩家飞出屏幕将会退格，即卡住不会前进</li>
<li>机器人飞出屏幕则会反向继续前进</li>
<li>子弹飞出屏幕则直接销毁</li>
<li>如果基地碰到bomb则两个都被销毁</li>
<li>如果基地碰到sam则两个都被销毁，加一分</li>
<li>如果基地碰到敌人，基地被销毁</li>
<li>如果玩家碰到敌人，玩家被摧毁，扣一分</li>
<li>如果玩家碰到bomb，玩家被摧毁，扣一分</li>
<li>如果敌人碰到sam，敌人被摧毁，得两分</li>
</ul>
</li>
<li>TerminationSet<ul>
<li>如果玩家数量为0，即玩家被摧毁，游戏失败</li>
<li>如果传送门和敌人的数量都为0，则游戏胜利</li>
</ul>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2021-04-10T19:35:55.000Z" title="2021-04-10T19:35:55.000Z">2021-04-10</time><span class="level-item">7 分钟 读完 (大约 1040 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/10/GVGAI%20Book%20Chapter%202%20-%20VGDL%20and%20the%20GVGAI%20Framework%20--%20Exercises/">GVGAI Book Chapter 2 - VGDL and the GVGAI Framework -- Exercises</a></h1><div class="content"><p><a href="https://gaigresearch.github.io/gvgaibook/">书籍网站</a><br><a href="https://gaigresearch.github.io/gvgaibook/PDF/chapters/ch02.pdf?raw=true">本章原文</a><br><a href="https://gaigresearch.github.io/gvgaibook/PDF/exercises/exercises02.pdf?raw=true">本章练习</a></p>
<hr>
<h1 id="GVGAI环境配置"><a href="#GVGAI环境配置" class="headerlink" title="GVGAI环境配置"></a>GVGAI环境配置</h1><p>Github中提供了<a href="https://github.com/GAIGResearch/GVGAI">GVGAI框架</a>。这里使用与书中匹配的<a href="https://github.com/GAIGResearch/GVGAI/releases/tag/2.3">2.3</a>版本来进行练习。</p>
<h2 id="下载并安装-IntelliJ"><a href="#下载并安装-IntelliJ" class="headerlink" title="下载并安装 IntelliJ"></a>下载并安装 IntelliJ</h2><p>IntelliJ<a href="https://www.jetbrains.com/idea/download/#section=windows">下载地址</a>与 JDK <a href="https://www.oracle.com/java/technologies/javase-downloads.html">下载地址</a>。</p>
<p>下载安装完成后导入项目，如图所示：</p>
<p><img src="https://raw.githubusercontent.com/rasin-tsukuba/blog-images/master/img/20210410195844.png" alt="项目总览"></p>
<h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><p>首先我们先试着用GVGAI运行游戏。可以使用键盘直接控制游玩，或者使用示例agent来自动测试。</p>
<h3 id="以玩家身份玩游戏"><a href="#以玩家身份玩游戏" class="headerlink" title="以玩家身份玩游戏"></a>以玩家身份玩游戏</h3><p>在左边的 <code>Project</code> 导航中选择 <code>src -&gt; tracks -&gt; singlePlayer -&gt; Test.java</code> 双击打开。</p>
<p>为了顺利编译文件，根据一下图示顺序设定好配置。配置名可以任意选择。</p>
<p><img src="https://raw.githubusercontent.com/rasin-tsukuba/blog-images/master/img/20210410200412.png" alt="第一步"></p>
<p><img src="https://raw.githubusercontent.com/rasin-tsukuba/blog-images/master/img/20210410200545.png" alt="第二步"></p>
<p>确认之后点击右上角的绿色运行按钮或者使用快捷键 <code>Shift+F10</code> 即可开始运行。</p>
<p><img src="https://raw.githubusercontent.com/rasin-tsukuba/blog-images/master/img/20210410200814.png" alt="SinglePlayer运行画面"></p>
<p>默认启动的游戏是 <code>Alians</code>，玩家通过键盘方向键<code>←→</code>和空格键进行操作。</p>
<h3 id="更改游戏"><a href="#更改游戏" class="headerlink" title="更改游戏"></a>更改游戏</h3><p>在代码中的<code>29</code>行我们可以看到游戏集文件 <code>examples/all_games_sp.csv</code>。使用CSV插件可以看到游戏列表：</p>
<p><img src="https://raw.githubusercontent.com/rasin-tsukuba/blog-images/master/img/20210410201344.png" alt="all_games_sp"></p>
<p>那么接下来在文件的 <code>37</code>行中，我们可以通过修改 <code>gameIdx</code> 来更改游戏。例如，将其修改为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int gameIdx &#x3D; 9;</span><br></pre></td></tr></table></figure>

<p>再次编译运行，游戏就变成了炸弹人：</p>
<p><img src="https://raw.githubusercontent.com/rasin-tsukuba/blog-images/master/img/20210410201650.png" alt="bomberman"></p>
<h3 id="用机器人玩游戏"><a href="#用机器人玩游戏" class="headerlink" title="用机器人玩游戏"></a>用机器人玩游戏</h3><p>要使用示例Agent来运行集合中的游戏时，请注释掉第 <code>49</code>行（这行代码是给玩家试玩使用的），并解开第 <code>52</code> 行注释。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. This starts a game, in a level, played by a human.</span><br><span class="line">&#x2F;&#x2F;ArcadeMachine.playOneGame(game, level1, recordActionsFile, seed);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2. This plays a game in a level by the controller.</span><br><span class="line">ArcadeMachine.runOneGame(game, level1, visuals, sampleRHEAController, recordActionsFile, seed, 0);</span><br></pre></td></tr></table></figure>

<p><code>runOneGame</code> 第四个函数指定Agent的位置（默认是 <code>Rolling Horizon Evolutionary Algorithm agent</code>）。</p>
<p>文件中第 <code>18</code> 至 <code>26</code>行定义了本框架中包含的实例Agents，例如 <code>Monte Carlo Tree Search agent</code> 和 <code>OLETS</code>。</p>
<h1 id="VGDL"><a href="#VGDL" class="headerlink" title="VGDL"></a>VGDL</h1><p><code>VGDL</code> 游戏都存储在 <code>example</code>文件夹中。每个游戏类别都有一个文件夹：<code>gridphysics</code> 和 <code>contphysics</code> 包含具有传统和现实世界物理引擎的单人游戏，<code>2player</code> 中都是双人游戏，<code>gameDesign</code> 包含参数化的游戏。</p>
<h2 id="修改游戏"><a href="#修改游戏" class="headerlink" title="修改游戏"></a>修改游戏</h2><p>可以尝试在 <code>example/gridphysics</code> 中打开一个 <code>VGDL</code>文件，一般以 <code>.txt</code> 后缀结尾。学习<code>VGDL</code>不同的部分可以从修改内容的值开始。也可以根据你的想法在 <code>InteractionSet</code> 中添加新的规则或者新的贴图。有可能你也能创造新的游戏。</p>
<h2 id="更改关卡"><a href="#更改关卡" class="headerlink" title="更改关卡"></a>更改关卡</h2><p>可以通过修改例如 <code>aliens_lvl0.txt</code> 之类的文件来更改关卡，比如关卡的布局，贴图的初始位置等等。可以给关卡增加不同难度或者创造新的关卡。</p>
<h1 id="提交到GVGAI比赛服务器"><a href="#提交到GVGAI比赛服务器" class="headerlink" title="提交到GVGAI比赛服务器"></a>提交到GVGAI比赛服务器</h1><p>一下是提交步骤：</p>
<ul>
<li>在 <a href="http://www.gvgai.net/">GAGVI官网</a> 创建账号。</li>
<li>登入并点击 <code>Submit → Submit to Signle Player Planning</code>。</li>
<li>您的控制器文件应命名为 <code>Agent.java</code>，并包含一个与您用户名相同的包，以 <code>.zip</code> 文件存储。网站中有更详尽的<a href="http://www.gvgai.net/submit_gvg.php">提交规范</a></li>
<li>填写需要的信息，并选择一个游戏集提交。您的代码将会在服务器上编译执行，具体提交信息可以在个人主页上查看。</li>
<li>一旦编译运行完成，你可以在排行版上看到您的结果。</li>
<li>如果您想参赛，可以先用示例代码提交测试。</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2021-03-23T19:35:55.000Z" title="2021-03-23T19:35:55.000Z">2021-03-23</time><span class="level-item">8 分钟 读完 (大约 1131 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/03/23/%E9%87%8D%E8%BF%94Gamemaker%20Studio2/">重返Gamemaker Studio 入门篇2</a></h1><div class="content"><p>在线文档: <a href="https://manual-en.yoyogames.com/#t=Content.htm">GameMaker Studio 2 Manual</a><br>官方社区: <a href="https://forum.yoyogames.com/index.php">GameMaker Community</a><br>知识库：<a href="https://help.yoyogames.com/hc/en-us/categories/204246668-GameMaker-Studio-2">GameMaker Knowledge Base</a></p>
<p>本系列参考的教程：<a href="https://www.youtube.com/watch?v=izNXbMdu348&list=PLPRT_JORnIupqWsjRpJZjG07N01Wsw_GJ">GameMaker Studio 2: Complete Platformer Tutorial</a></p>
<hr>
<h2 id="添加枪械"><a href="#添加枪械" class="headerlink" title="添加枪械"></a>添加枪械</h2><p>人物将会携带枪支进行射击。首先要添加枪械的贴图和对象。由于枪械是一个长矩形，并且根据常识，人物应该在枪械的后半部把持着。因此，将枪械的原点设在偏后半部的中心位置比较妥当。</p>
<p><img src="https://raw.githubusercontent.com/rasin-tsukuba/blog-images/master/img/20210227201918.png" alt="Gun"></p>
<p>再者，枪械一般位于胸部位置，而玩家贴图是Q版一比一身材，因此将其置于身体中心再向下一些的位置。我们在 <code>oGun</code> 对象的 <code>BeginStep</code> 事件中添加代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D; oPlayer.x</span><br><span class="line">y &#x3D; oPlayer.y + 9 &#x2F;&#x2F;较为合适的位置</span><br></pre></td></tr></table></figure>

<p>我们希望枪械的前端将会指向鼠标的方向，并且鼠标在人物左右的时候，枪械也会自动跟随鼠标翻转：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">image_angle &#x3D; point_direction(x, y, mouse_x, mouse_y) &#x2F;&#x2F;鼠标的坐标</span><br><span class="line">if (image_angle &gt; 90) and (image_angle &lt; 270)&#123; &#x2F;&#x2F;逆时针计算角度，零度为正下方</span><br><span class="line">    image_yscale &#x3D; -1</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">    image_yscale &#x3D; 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加子弹"><a href="#添加子弹" class="headerlink" title="添加子弹"></a>添加子弹</h2><p>子弹是一个两帧动画，首先是一个圆形，之后变成一个带着小尾巴的圆。我们希望子弹在发射出去之后，保持第二帧动画不变，直到碰到墙壁消失。那么可以通过 <code>oBullet</code>对象的 <code>Animation End</code> 事件代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">image_speed &#x3D; 0 &#x2F;&#x2F;当动画结束时，将动画速度设为0，即不再播放</span><br><span class="line">image_index &#x3D; 1 &#x2F;&#x2F;将动画帧数设为第二帧</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/rasin-tsukuba/blog-images/master/img/20210227201857.png" alt="Bullet"></p>
<p>接下来，在 <code>Post Draw</code> 事件中，我们添加碰到墙体后子弹销毁的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (place_meeting(x, y, oWall))</span><br><span class="line">    instance_destroy() &#x2F;&#x2F;该实例销毁</span><br></pre></td></tr></table></figure>

<p>这里的 <code>Post Draw</code> 事件，是指在绘制一旦结束之后就立即检测。官方文档的解释是：</p>
<blockquote>
<p>The <strong>Post Draw</strong> event is triggered after the standard draw events, but before the Draw GUI events. Like the Pre Draw event, it is based on the size of the screen buffer size, and is placed before the Draw GUI events to enable you to perform post-processing effects and other things on a full screen basis simply and easily without interfering with any HUD/GUI elements that you may have in your game.</p>
</blockquote>
<p>论坛中网友的解释是</p>
<blockquote>
<p>the Post Draw event is the moment in between the Draw events and the image being sent to the screen.</p>
</blockquote>
<p>简单点理解就是，游戏引擎在绘制之后，还没有把绘制完成的东西送到显示屏上就立即执行的事件。</p>
<h2 id="枪械射击与后坐力"><a href="#枪械射击与后坐力" class="headerlink" title="枪械射击与后坐力"></a>枪械射击与后坐力</h2><p>枪械连击中间需要加入一个延迟，并且枪械在发射子弹的过程中最好还带有一个后坐力的效果。首先我们先在 <code>oGun</code> 的 <code>Create</code> 事件中声明一下相关变量:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firingdelay &#x3D; 1 &#x2F;&#x2F; 发射间隔</span><br><span class="line">recoil &#x3D; 0 &#x2F;&#x2F; 后坐力</span><br></pre></td></tr></table></figure>

<p>依旧是在 <code>Begin Step</code> 事件中，我们添加对于射击延迟和后坐力的一个检测：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">firingdelay &#x3D; firingdelay - 1 &#x2F;&#x2F; 每个时间片减少1计时</span><br><span class="line">recoil &#x3D; max(0, recoil - 1) &#x2F;&#x2F; 后坐力取0和当前值减1的最大值</span><br><span class="line"></span><br><span class="line">if (mouse_check_button(mb_left)) &amp;&amp; (fd&lt;0)&#123; &#x2F;&#x2F;当鼠标左键点击并且延迟计时小于0时</span><br><span class="line">    recoil &#x3D; 4  &#x2F;&#x2F;设定后坐力</span><br><span class="line">    fd &#x3D; 5  &#x2F;&#x2F;设定设计间隔</span><br><span class="line">    </span><br><span class="line">    with (instance_create_layer(x, y, &quot;Bullets&quot;, oBullet))&#123; &#x2F;&#x2F;with 语句</span><br><span class="line">        speed &#x3D; 25 &#x2F;&#x2F; 将对应创建的新bullet对象赋予速度</span><br><span class="line">        direction &#x3D; other.image_angle + random_range(-3, 3) &#x2F;&#x2F; other 指with中指代的对象，这里加入一个随机数使得子弹不会单纯往一个方向设计，而是在一个小的随机范围内发射</span><br><span class="line">        image_angle &#x3D; direction &#x2F;&#x2F;重新设定子弹行进的方向</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x &#x3D; x - lengthdir_x(recoil, image_angle) &#x2F;&#x2F;往发射角度的反向延长线上后退</span><br><span class="line">y &#x3D; y - lengthdir_y(recoil, image_angle)</span><br></pre></td></tr></table></figure>

<p>官方文档中对于 <code>with</code> 语句的解释是：</p>
<blockquote>
<p>In a number of cases you want to do a lot more than just change a single variable within those other instances, and may want to perform more complex code actions that require multiple functions and lines of code.</p>
</blockquote>
<blockquote>
<p>Once the expression has set the scope of the with, the statement will then be executed for each of the indicated instances, as if that instance is the current (self) instance.</p>
</blockquote>
<p>也就是说，<code>with</code> 可以再指定一个新对象，这个新对象在 <code>with</code> 语句中用 <code>other</code> 来指代。</p>
<p>这时候要记得在 <code>Room1</code> 中添加两个新层 <code>Bullets</code> 和 <code>Gun</code>，这两层应置于 <code>Player</code>上方。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2021-02-23T19:35:55.000Z" title="2021-02-23T19:35:55.000Z">2021-02-23</time><span class="level-item">17 分钟 读完 (大约 2543 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/02/23/%E9%87%8D%E8%BF%94Gamemaker%20Studio1/">重返Gamemaker Studio 入门篇1</a></h1><div class="content"><blockquote>
<p>空有雄心壮志，不如脚踏实地从简单做起。</p>
</blockquote>
<p>经历了三年空窗期，虽说实际情况产生了不可计量的变化，也和当时想做游戏的简单初衷相去甚远。但愿望如果不开始付诸实际，只会停留在空想。因此还是准备从简单做起，不想因为复杂的实现和编程花费太多时间，而把重心侧重在玩法和构思上面，GameMaker Studio 2 貌似是一个比较折中的选择。闲话少叙，从一个简单的平台冒险类游戏下手，基本能够达到目前构思游戏demo的制作需求。本系列的目的是在跟着教程实践的基础上，对游戏制作过程的一个简单记录，仅供自己回顾，不做教程目的。</p>
<hr>
<p>在线文档: <a href="https://manual-en.yoyogames.com/#t=Content.htm">GameMaker Studio 2 Manual</a><br>官方社区: <a href="https://forum.yoyogames.com/index.php">GameMaker Community</a><br>知识库：<a href="https://help.yoyogames.com/hc/en-us/categories/204246668-GameMaker-Studio-2">GameMaker Knowledge Base</a></p>
<p>本系列参考的教程：<a href="https://www.youtube.com/watch?v=izNXbMdu348&list=PLPRT_JORnIupqWsjRpJZjG07N01Wsw_GJ">GameMaker Studio 2: Complete Platformer Tutorial</a></p>
<hr>
<h2 id="界面介绍"><a href="#界面介绍" class="headerlink" title="界面介绍"></a>界面介绍</h2><p>在打开游戏IDE之后，我们可以看到几个区域。如图所示，中间部分是工作区，所有基本的元素编辑和代码撰写都在这里。右边是素材区，已经被多个文件夹详细划分。左上是菜单栏和工具栏，最左一栏为房间设置栏，之后再详细讨论其使用方法。</p>
<p><img src="https://raw.githubusercontent.com/rasin-tsukuba/blog-images/master/img/20210223200012.png" alt="IDE"></p>
<p>工作区的操作同大多数游戏一样，通过滚轮滑动调整上下，点击中键进行移动，按住<code>Ctrl</code>键加上滚轮滑动可以控制工作区的界面缩放，也可以使用 <code>Ctrl + +</code> 和 <code>Ctrl + -</code> 达到相同效果。</p>
<p>再进行工作的时候，可以使用快捷键 <code>F12</code> 将工作区最大化，方便编辑。</p>
<h2 id="创建贴图"><a href="#创建贴图" class="headerlink" title="创建贴图"></a>创建贴图</h2><p>可以直接在工作区里点击 <code>右键→Assets→Create Sprite</code>；或者在素材区对应的文件夹里如前者一般创建。唯一的区别是，直接在工作区里创建的文件存储在根目录，而对应文件夹创建可以更加分门别类，当然也可以重新拖放文件达到相同效果。同理，其他需要创建的东西也可以这样操作。</p>
<p>以下就是一个空的贴图文件配置。</p>
<p><img src="https://raw.githubusercontent.com/rasin-tsukuba/blog-images/master/img/20210223200815.png" alt="sprite"></p>
<p>贴图可以根据我们的需要进行命名，命名一般需要规则，如玩家静止贴图用 <code>sPlayer</code>, 玩家跑动贴图用 <code>sPlayerR</code>，玩家跳跃贴图用 <code>sPlayerA</code>。下方的 <code>Size</code> 需要注意，一般是 <code>64*64</code> 的像素大小，也可以点击按钮进行调整。右边的 <code>Edit Image</code> 可以直接在编辑器里面编辑。我个人觉得还是使用更完备的外部编辑器画好再导入进来，比如 <code>Aseprite</code> 或 <code>Photoshop</code>等等。下面的 <code>Import</code> 按钮可以导入图片。导入图片可以是单张贴图或者多帧动画。注意这里导入的动画实际上是拼贴好的 <code>png</code> 文件，文件名以 <code>_strip(num)</code> 结尾，其中 <code>num</code> 是实际上帧的数量。这样导入的图片将会自动被切割成 <code>num</code> 数量的帧。如下图所示，一张拼贴好的4帧 <code>sPlayer_r_strip4.png</code> 文件：</p>
<p><img src="https://raw.githubusercontent.com/rasin-tsukuba/blog-images/master/img/20210223202502.png" alt="strip_4"></p>
<p>左下角的 <code>Collision Mask</code> 是用于检测游戏对象碰撞的大小，可以通过手动自行设置或者自动检测来调整。</p>
<p>右侧是动画界面，右上角是动画帧率。注意这里的帧率<strong>仅用于显示</strong>，而<strong>不是</strong>指游戏内的<strong>实际帧率</strong>。右边的坐标指定该贴图的圆心位置，一般可以直接使用 <code>Middle Centre</code> 让系统自动指定。</p>
<p>这里我们创建了两个基本的贴图：<code>sPlayer</code>和 <code>sWall</code>，并将素材导入。</p>
<p><img src="https://raw.githubusercontent.com/rasin-tsukuba/blog-images/master/img/20210223214139.png" alt=""></p>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>贴图只是纯粹的图片，不能执行游戏中的指令和效果，因此就需要创建对象并绑定贴图。首先，我们先创建一个玩家对象 <code>oPlayer</code>，并将刚才创建好的 <code>sPlayer</code> 进行绑定。</p>
<p><img src="https://raw.githubusercontent.com/rasin-tsukuba/blog-images/master/img/20210223214535.png" alt="oPlayer"></p>
<p>下方的 <code>Events</code> 可以用来管理对象相关的所有事件。点击并创建新的事件。首先，<code>Create</code> 事件对应在对象创建时，我们需要初始化一些简单的变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hsp &#x3D; 0    &#x2F;&#x2F;水平速度</span><br><span class="line">vsp &#x3D; 0    &#x2F;&#x2F;垂直速度</span><br><span class="line">grv &#x3D; 0.3  &#x2F;&#x2F;重力</span><br><span class="line">walksp &#x3D; 4 &#x2F;&#x2F;行走速度</span><br></pre></td></tr></table></figure>

<p>紧接着，我们创建 <code>Step</code>事件。<code>Step</code> 事件管理每个时间片里面需要执行的内容，因此代码会较为复杂。首先定义以下按键：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Get Player Input</span><br><span class="line">key_left &#x3D; keyboard_check(vk_left) || keyboard_check(ord(&quot;A&quot;)) &#x2F;&#x2F;方向键左或者键A</span><br><span class="line">key_right &#x3D; keyboard_check(vk_right)|| keyboard_check(ord(&quot;D&quot;)); &#x2F;&#x2F;方向键右或者键D</span><br><span class="line">key_jump &#x3D; keyboard_check_pressed(vk_space)|| keyboard_check_pressed(ord(&quot;W&quot;)); &#x2F;&#x2F;空格键或键W，仅需点击即可</span><br></pre></td></tr></table></figure>

<p>这样就定义好了基本的行动按键。接下来，对应的按键要加上其逻辑才能有实际意义。我们继续定义一下运动的状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var move &#x3D; key_right - key_left &#x2F;&#x2F; &#96;var&#96; 用于声明局部变量</span><br><span class="line">hsp &#x3D; move * walksp &#x2F;&#x2F; 水平速度等于行动方向乘行走速度</span><br><span class="line">vsp &#x3D; vsp + grv;  &#x2F;&#x2F; 垂直速度等于现有垂直速度加上重力速度</span><br></pre></td></tr></table></figure>

<p>首先定义了一个临时变量 <code>move</code>。<code>move</code> 在这里是一个布尔值，当 <code>key_right</code>为 <code>True</code> 且 <code>key_left</code> 为 <code>False</code> 时，<code>move</code>值为 <code>1</code> ；当 <code>key_right</code>为 <code>False</code> 且 <code>key_left</code> 为 <code>True</code> 时，<code>move</code> 值为 <code>-1</code> 。这样就可以将作为一个方向的标识。</p>
<p>正如我们在 <code>Create</code> 事件中定义的几个基础的速度变量，在 <code>Step</code> 事件中需要对行进速度进行实时更改。对于水平速度如此定义无可厚非，但垂直速度并没有按照物理学的实际情况算上加速度，只是简单的通过在每个时间片减去重力的速度达到下落的效果。</p>
<h2 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h2><p>如果不做碰撞检测，那么人物在水平行进和下落的时候就不会被墙阻挡住，就没有办法进行游戏。因此要对人物和墙体之间做碰撞检测。先从跳跃开始：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Jump</span><br><span class="line">if (place_meeting(x, y+1, oWall)) &amp;&amp; (key_jump)&#123;</span><br><span class="line">    vsp &#x3D; -7</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>place_meeting</code> 函数用于检查某个对象实例的 <code>Collision Mask</code> 与另一个实例或对象的所有实例的碰撞检测。因此这个函数可以检测玩家对象和所有的墙体，而不需要对单个墙体进行设定。由于房间坐标的左上顶点是 <code>(0, 0)</code>，因此垂直的负方向是向上，因此向上跳跃的速度设为负值。触发跳跃的条件是当玩家位于墙对象上分且按下跳跃。</p>
<p>水平移动要算上玩家的移动速度。因此在 <code>place_meeting</code> 函数中需要注意：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (place_meeting(x+hsp, y, oWall))&#123; &#x2F;&#x2F;加上玩家的速度 也就是下一个时间片原本的位移</span><br><span class="line">    while (!place_meeting(x+sign(hsp), y, oWall))&#123; &#x2F;&#x2F;当还没碰到墙时要继续移动，这里用方向表示更简洁</span><br><span class="line">        x &#x3D; x + sign(hsp) &#x2F;&#x2F;继续移动到墙边</span><br><span class="line">    &#125;</span><br><span class="line">    hsp &#x3D; 0 &#x2F;&#x2F;将移动速度设为0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x &#x3D; x + hsp; &#x2F;&#x2F;更改玩家横坐标位置</span><br></pre></td></tr></table></figure>

<p>同理，垂直移动也可以用类似的代码来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Vertical Collision</span><br><span class="line">if (place_meeting(x, y+vsp, oWall))&#123;</span><br><span class="line">	</span><br><span class="line">	while (!place_meeting(x, y+sign(vsp), oWall))&#123;</span><br><span class="line">		y &#x3D; y + sign(vsp);</span><br><span class="line">	&#125;</span><br><span class="line">	vsp &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">y &#x3D; y + vsp;</span><br></pre></td></tr></table></figure>

<h2 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h2><p>在移动的基础上增加动画能使得游戏演示看起来更自然生动。这里重新创建两个贴图：<code>sPlayerR</code> 为奔跑动画，<code>sPlayerA</code> 为在空中的动画。我们需要玩家在跑动的时候播放奔跑动画，在跳跃的时候播放空中的动画。现在依旧需要用碰撞来检测玩家的具体位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">if (!place_meeting(x, y+1, oWall))&#123; &#x2F;&#x2F;不和墙体接触，即在空中时</span><br><span class="line">    sprite_index &#x3D; sPlayerA &#x2F;&#x2F;将动画切换成空中动画</span><br><span class="line">    image_speed &#x3D; 0 &#x2F;&#x2F; 将动画循环速度常数设为0，即整个动作只播放一次</span><br><span class="line">    if (sign(vsp) &gt; 0)&#123; &#x2F;&#x2F;若玩家处于下落状态时</span><br><span class="line">        image_index &#x3D; 1; &#x2F;&#x2F;仅播放第二帧</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        image_index &#x3D; 0; &#x2F;&#x2F;播放第一帧</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">else&#123; &#x2F;&#x2F;在地面的情况</span><br><span class="line">    image_speed &#x3D; 1; &#x2F;&#x2F;常速播放动画</span><br><span class="line">    if (hsp &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        sprite_index &#x3D; sPlayer &#x2F;&#x2F;播放静止动画</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        sprite_index &#x3D; sPlayerR &#x2F;&#x2F;播放运动动画</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跑动也有正反方向。Gamemaker Studio 提供了一个取巧的功能使得美术不需要画两个方向的动画：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (hsp !&#x3D;0)&#123; &#x2F;&#x2F;在水平运动的时候</span><br><span class="line">    image_xscale &#x3D; sign(hsp) &#x2F;&#x2F;运动方向的正负决定动画方向</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="房间设置"><a href="#房间设置" class="headerlink" title="房间设置"></a>房间设置</h2><p>做好了基本的对象和相关事件，我们应该将其放到实际的游戏中进行测试。在 <code>Rooms</code> 文件夹中创建一个新房间 <code>Room1</code>。界面的左上方有一个房间图层，如同 <code>Photoshop</code> 一样，居于最上的最前，居于最下的最后。除了原有的 <code>Background</code>，我们创建两个新的图层 <code>Player</code>和 <code>Wall</code>。</p>
<p><img src="https://raw.githubusercontent.com/rasin-tsukuba/blog-images/master/img/20210225195516.png" alt="Layers"></p>
<p>之后我们将玩家对象和墙体对象拖入，按住 <code>alt</code> 键可以批量生成。如下图就是一个房间的示例：</p>
<p><img src="https://raw.githubusercontent.com/rasin-tsukuba/blog-images/master/img/20210225200123.png" alt="Room1"></p>
<p>如果没有什么问题的话，点击上方的 <code>Run</code> 按钮或快捷键 <code>F5</code>就可以运行游戏了。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-06-12T15:31:55.000Z" title="2020-06-12T15:31:55.000Z">2020-06-12</time><span class="level-item">8 分钟 读完 (大约 1161 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/06/12/%E7%8B%AC%E4%B8%8E%E5%AD%A4/">独与孤</a></h1><div class="content"><p><img src="https://raw.githubusercontent.com/rasin-tsukuba/blog-images/master/img/20200612160917.jpg" alt=""></p>
<p>2020年6月12日，已经是第26个生日了。我在今天收获了三个生日祝福，两个是不同阶段的同学，一个是网友。</p>
<p>首先应该感谢在这个世界上，在我没有声张的情况，还有人主动给我送来祝福。自然而然，“三个祝福”固然对于一些人来说过于少而感到可笑，我也一时因此气馁。相较于过去而言，在学生时代也有班级或者好友给予无论是口头还是礼物的祝福，或者是工作时公司的生日福利，一群人凑在一起吃吃喝喝来庆祝某几个相同月份的人生日，确实仅有的几个口头祝福是寒酸了一点吧。</p>
<p>比起回忆，更重要的是心意。除了家人以外，有牵挂你的朋友、同学以及同事，或者相隔千里之外的网友，近年来已逐渐不敢奢求了。主要的原因当然是自己不去表达自己的期望，还有逐渐减少的社交频次，以及就是在交往过程中更加谨慎了吧。为了不触及对方的神经令其敏感，主动减少需要表达的内容，以获取交往过程中微妙的距离感，得到四平八稳的人际关系。这样的行为导致的结果也应该是咎由自取吧。</p>
<p>而心态的转变在于，从“仅有”三个，到“还有”三个，是不是已经开始接受了这样的现实呢。已经还有三个了，就不用提过多要求了吧。当然，同时还要感谢银行、保险和社交平台等等，从冷冰冰的机器定期服务中用热情洋溢的字眼提醒我今天生日这回事。感谢！</p>
<p>说起来，自今年年初离职开始，已经在家三个月有余了。不知不觉一年已经过去二分之一，一边惊讶于白驹过隙，一边哀伤于毫无长进。三口之家的双职工家庭，离职的只可能独自一人在家，除了父母下班之后的一些交流，其余时间基本都是一个人度过。从一开始的放松，自由的心态，到现在习惯于一人食、一人眠，甚至有时开始渴望与人对话交流。人果然是社会性动物，一个人独处久了，果然还是会想念回归社会吧。但我依然以疫情为由避免了很多聚餐，以繁忙为由婉拒了一些聚会，以抱恙为由谢绝了不少机会。</p>
<p>原本定好的计划已经支离破碎，距离开始新生活的日子遥遥无期。</p>
<p>一个人的时候总是喜欢胡思乱想，便开始悲天悯人、顾影自怜起来了。</p>
<p>独处给了我更多的时间，而我却任其挥霍。</p>
<p>然而为什么不换个方向来考虑呢？</p>
<p>一个房间便是一个世界。由于我在其中，因此手头的工具便赋予了意义，创造便有了容身之处，思想虽难以碰撞，却可以孜孜不倦取前人及当代精华。</p>
<p>可以调素琴，阅金经。无丝竹之乱耳，无案牍之劳形。</p>
<p>乐观地来说，独处也算是独而不孤吧。</p>
<p>避免了纷繁的外界，无需根据流行刻意，不要依照指示而执行。独处之时，自己便是全部，思绪漫布也无伤大雅，天马行空也安之若素。不用活在眼光之中，不须听取口舌之燥。这样也算是一种解脱。</p>
<p>虽然前途未卜，但是这样的日子还能持续多久呢？当一切走上正轨，也就是宣告一个时期的结束了。</p>
<p>这一段悠长假期，没有艳遇和激情，来弥补的是思考和自省。</p>
<p>漫天烦恼和忧愁的云雾，何时可以拨云见日呢？</p>
<p>独处给了我更多的时间，我愿窥见星辰。</p>
<p><img src="https://raw.githubusercontent.com/rasin-tsukuba/blog-images/master/img/20200612160936.jpg" alt=""></p>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="" src="/img/avatar.png" alt="Rasin Gue"></figure><p class="title is-size-4 is-block line-height-inherit">Rasin Gue</p><p class="is-size-6 is-block">PhD in Progress</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Tsukuba, Japan</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">6</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">5</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/RasinGue" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/RasinGue"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/mizumori_setsu"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com/rasin"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li></ul></div></div></div><!--!--><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2021-04-12T10:35:55.000Z">2021-04-12</time></p><p class="title is-6"><a class="link-muted" href="/2021/04/12/GVGAI%20Book%20Chapter%203%20-%20Planning%20in%20GVGAI/">GVGAI Book Chapter 3 - Planning in GVGAI</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2021-04-11T19:35:55.000Z">2021-04-11</time></p><p class="title is-6"><a class="link-muted" href="/2021/04/11/VGDL%E8%8C%83%E4%BE%8B%E8%A7%A3%E8%AF%BB/">VGDL范例解读</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2021-04-10T19:35:55.000Z">2021-04-10</time></p><p class="title is-6"><a class="link-muted" href="/2021/04/10/GVGAI%20Book%20Chapter%202%20-%20VGDL%20and%20the%20GVGAI%20Framework%20--%20Exercises/">GVGAI Book Chapter 2 - VGDL and the GVGAI Framework -- Exercises</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2021-03-23T19:35:55.000Z">2021-03-23</time></p><p class="title is-6"><a class="link-muted" href="/2021/03/23/%E9%87%8D%E8%BF%94Gamemaker%20Studio2/">重返Gamemaker Studio 入门篇2</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2021-02-23T19:35:55.000Z">2021-02-23</time></p><p class="title is-6"><a class="link-muted" href="/2021/02/23/%E9%87%8D%E8%BF%94Gamemaker%20Studio1/">重返Gamemaker Studio 入门篇1</a></p><p class="is-uppercase"></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/GVGAI-AI/"><span class="tag">GVGAI; AI</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GVGAI-VGDL/"><span class="tag">GVGAI; VGDL</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Gamemaker-Studio/"><span class="tag">Gamemaker Studio</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/VGDL/"><span class="tag">VGDL</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/joural/"><span class="tag">joural</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Rasin&#039;s Blog" height="28"></a><p class="size-small"><span>&copy; 2021 Rasin Gue</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://rasin.me',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>